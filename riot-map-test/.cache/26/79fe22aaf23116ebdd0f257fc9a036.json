{"id":"node_modules/riot/riot.js","dependencies":[{"name":"/Users/brandonbuttars/Dropbox/Fortem/Sandbox/frontend-mapbox-tests/riot-map-test/package.json","includedInParent":true,"mtime":1549005863945},{"name":"/Users/brandonbuttars/Dropbox/Fortem/Sandbox/frontend-mapbox-tests/riot-map-test/.babelrc","includedInParent":true,"mtime":1549005515533},{"name":"/Users/brandonbuttars/Dropbox/Fortem/Sandbox/frontend-mapbox-tests/riot-map-test/node_modules/riot/package.json","includedInParent":true,"mtime":1549000028509}],"generated":{"js":"var define;\nvar global = arguments[3];\n/* Riot v3.13.2, @license MIT */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global.riot = {});\n})(this, function (exports) {\n  'use strict';\n  /**\n   * Shorter and fast way to select a single node in the DOM\n   * @param   { String } selector - unique dom selector\n   * @param   { Object } ctx - DOM node where the target of our search will is located\n   * @returns { Object } dom node found\n   */\n\n  function $(selector, ctx) {\n    return (ctx || document).querySelector(selector);\n  }\n\n  var // be aware, internal usage\n  // ATTENTION: prefix the global dynamic variables with `__`\n  // tags instances cache\n  __TAGS_CACHE = [],\n      // tags implementation cache\n  __TAG_IMPL = {},\n      YIELD_TAG = 'yield',\n\n  /**\n   * Const\n   */\n  GLOBAL_MIXIN = '__global_mixin',\n      // riot specific prefixes or attributes\n  ATTRS_PREFIX = 'riot-',\n      // Riot Directives\n  REF_DIRECTIVES = ['ref', 'data-ref'],\n      IS_DIRECTIVE = 'data-is',\n      CONDITIONAL_DIRECTIVE = 'if',\n      LOOP_DIRECTIVE = 'each',\n      LOOP_NO_REORDER_DIRECTIVE = 'no-reorder',\n      SHOW_DIRECTIVE = 'show',\n      HIDE_DIRECTIVE = 'hide',\n      KEY_DIRECTIVE = 'key',\n      RIOT_EVENTS_KEY = '__riot-events__',\n      // for typeof == '' comparisons\n  T_STRING = 'string',\n      T_OBJECT = 'object',\n      T_UNDEF = 'undefined',\n      T_FUNCTION = 'function',\n      XLINK_NS = 'http://www.w3.org/1999/xlink',\n      SVG_NS = 'http://www.w3.org/2000/svg',\n      XLINK_REGEX = /^xlink:(\\w+)/,\n      WIN = typeof window === T_UNDEF ?\n  /* istanbul ignore next */\n  undefined : window,\n      // special native tags that cannot be treated like the others\n  RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/,\n      RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/,\n      RE_EVENTS_PREFIX = /^on/,\n      RE_HTML_ATTRS = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g,\n      // some DOM attributes must be normalized\n  CASE_SENSITIVE_ATTRIBUTES = {\n    'viewbox': 'viewBox',\n    'preserveaspectratio': 'preserveAspectRatio'\n  },\n\n  /**\n   * Matches boolean HTML attributes in the riot tag definition.\n   * With a long list like this, a regex is faster than `[].indexOf` in most browsers.\n   * @const {RegExp}\n   * @see [attributes.md](https://github.com/riot/compiler/blob/dev/doc/attributes.md)\n   */\n  RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/,\n      // version# for IE 8-11, 0 for others\n  IE_VERSION = (WIN && WIN.document ||\n  /* istanbul ignore next */\n  {}).documentMode | 0;\n  /**\n   * Create a generic DOM node\n   * @param   { String } name - name of the DOM node we want to create\n   * @returns { Object } DOM node just created\n   */\n\n  function makeElement(name) {\n    return name === 'svg' ? document.createElementNS(SVG_NS, name) : document.createElement(name);\n  }\n  /**\n   * Set any DOM attribute\n   * @param { Object } dom - DOM node we want to update\n   * @param { String } name - name of the property we want to set\n   * @param { String } val - value of the property we want to set\n   */\n\n\n  function setAttribute(dom, name, val) {\n    var xlink = XLINK_REGEX.exec(name);\n\n    if (xlink && xlink[1]) {\n      dom.setAttributeNS(XLINK_NS, xlink[1], val);\n    } else {\n      dom.setAttribute(name, val);\n    }\n  }\n\n  var styleNode; // Create cache and shortcut to the correct property\n\n  var cssTextProp;\n  var byName = {};\n  var needsInject = false; // skip the following code on the server\n\n  if (WIN) {\n    styleNode = function () {\n      // create a new style element with the correct type\n      var newNode = makeElement('style'); // replace any user node or insert the new one into the head\n\n      var userNode = $('style[type=riot]');\n      setAttribute(newNode, 'type', 'text/css');\n      /* istanbul ignore next */\n\n      if (userNode) {\n        if (userNode.id) {\n          newNode.id = userNode.id;\n        }\n\n        userNode.parentNode.replaceChild(newNode, userNode);\n      } else {\n        document.head.appendChild(newNode);\n      }\n\n      return newNode;\n    }();\n\n    cssTextProp = styleNode.styleSheet;\n  }\n  /**\n   * Object that will be used to inject and manage the css of every tag instance\n   */\n\n\n  var styleManager = {\n    styleNode: styleNode,\n\n    /**\n     * Save a tag style to be later injected into DOM\n     * @param { String } css - css string\n     * @param { String } name - if it's passed we will map the css to a tagname\n     */\n    add: function add(css, name) {\n      byName[name] = css;\n      needsInject = true;\n    },\n\n    /**\n     * Inject all previously saved tag styles into DOM\n     * innerHTML seems slow: http://jsperf.com/riot-insert-style\n     */\n    inject: function inject() {\n      if (!WIN || !needsInject) {\n        return;\n      }\n\n      needsInject = false;\n      var style = Object.keys(byName).map(function (k) {\n        return byName[k];\n      }).join('\\n');\n      /* istanbul ignore next */\n\n      if (cssTextProp) {\n        cssTextProp.cssText = style;\n      } else {\n        styleNode.innerHTML = style;\n      }\n    },\n\n    /**\n     * Remove a tag style of injected DOM later.\n     * @param {String} name a registered tagname\n     */\n    remove: function remove(name) {\n      delete byName[name];\n      needsInject = true;\n    }\n  };\n  /**\n   * The riot template engine\n   * @version v3.0.8\n   */\n\n  /* istanbul ignore next */\n\n  var skipRegex = function () {\n    //eslint-disable-line no-unused-vars\n    var beforeReChars = '[{(,;:?=|&!^~>%*/';\n    var beforeReWords = ['case', 'default', 'do', 'else', 'in', 'instanceof', 'prefix', 'return', 'typeof', 'void', 'yield'];\n    var wordsLastChar = beforeReWords.reduce(function (s, w) {\n      return s + w.slice(-1);\n    }, '');\n    var RE_REGEX = /^\\/(?=[^*>/])[^[/\\\\]*(?:(?:\\\\.|\\[(?:\\\\.|[^\\]\\\\]*)*\\])[^[\\\\/]*)*?\\/[gimuy]*/;\n    var RE_VN_CHAR = /[$\\w]/;\n\n    function prev(code, pos) {\n      while (--pos >= 0 && /\\s/.test(code[pos])) {}\n\n      return pos;\n    }\n\n    function _skipRegex(code, start) {\n      var re = /.*/g;\n      var pos = re.lastIndex = start++;\n      var match = re.exec(code)[0].match(RE_REGEX);\n\n      if (match) {\n        var next = pos + match[0].length;\n        pos = prev(code, pos);\n        var c = code[pos];\n\n        if (pos < 0 || ~beforeReChars.indexOf(c)) {\n          return next;\n        }\n\n        if (c === '.') {\n          if (code[pos - 1] === '.') {\n            start = next;\n          }\n        } else if (c === '+' || c === '-') {\n          if (code[--pos] !== c || (pos = prev(code, pos)) < 0 || !RE_VN_CHAR.test(code[pos])) {\n            start = next;\n          }\n        } else if (~wordsLastChar.indexOf(c)) {\n          var end = pos + 1;\n\n          while (--pos >= 0 && RE_VN_CHAR.test(code[pos])) {}\n\n          if (~beforeReWords.indexOf(code.slice(pos + 1, end))) {\n            start = next;\n          }\n        }\n      }\n\n      return start;\n    }\n\n    return _skipRegex;\n  }();\n  /**\n   * riot.util.brackets\n   *\n   * - `brackets    ` - Returns a string or regex based on its parameter\n   * - `brackets.set` - Change the current riot brackets\n   *\n   * @module\n   */\n\n  /* global riot */\n\n  /* istanbul ignore next */\n\n\n  var brackets = function (UNDEF) {\n    var REGLOB = 'g',\n        R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n        R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'|`[^`\\\\]*(?:\\\\[\\S\\s][^`\\\\]*)*`/g,\n        S_QBLOCKS = R_STRINGS.source + '|' + /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' + /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?([^<]\\/)[gim]*/.source,\n        UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n        NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n        S_QBLOCK2 = R_STRINGS.source + '|' + /(\\/)(?![*\\/])/.source,\n        FINDBRACES = {\n      '(': RegExp('([()])|' + S_QBLOCK2, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBLOCK2, REGLOB),\n      '{': RegExp('([{}])|' + S_QBLOCK2, REGLOB)\n    },\n        DEFAULT = '{ }';\n    var _pairs = ['{', '}', '{', '}', /{[^}]*}/, /\\\\([{}])/g, /\\\\({)|{/g, RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCK2, REGLOB), DEFAULT, /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/, /(^|[^\\\\]){=[\\S\\s]*?}/];\n\n    var cachedBrackets = UNDEF,\n        _regex,\n        _cache = [],\n        _settings;\n\n    function _loopback(re) {\n      return re;\n    }\n\n    function _rewrite(re, bp) {\n      if (!bp) {\n        bp = _cache;\n      }\n\n      return new RegExp(re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : '');\n    }\n\n    function _create(pair) {\n      if (pair === DEFAULT) {\n        return _pairs;\n      }\n\n      var arr = pair.split(' ');\n\n      if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n        throw new Error('Unsupported brackets \"' + pair + '\"');\n      }\n\n      arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '));\n      arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr);\n      arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr);\n      arr[6] = _rewrite(_pairs[6], arr);\n      arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCK2, REGLOB);\n      arr[8] = pair;\n      return arr;\n    }\n\n    function _brackets(reOrIdx) {\n      return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx];\n    }\n\n    _brackets.split = function split(str, tmpl, _bp) {\n      // istanbul ignore next: _bp is for the compiler\n      if (!_bp) {\n        _bp = _cache;\n      }\n\n      var parts = [],\n          match,\n          isexpr,\n          start,\n          pos,\n          re = _bp[6];\n      var qblocks = [];\n      var prevStr = '';\n      var mark, lastIndex;\n      isexpr = start = re.lastIndex = 0;\n\n      while (match = re.exec(str)) {\n        lastIndex = re.lastIndex;\n        pos = match.index;\n\n        if (isexpr) {\n          if (match[2]) {\n            var ch = match[2];\n            var rech = FINDBRACES[ch];\n            var ix = 1;\n            rech.lastIndex = lastIndex;\n\n            while (match = rech.exec(str)) {\n              if (match[1]) {\n                if (match[1] === ch) {\n                  ++ix;\n                } else if (! --ix) {\n                  break;\n                }\n              } else {\n                rech.lastIndex = pushQBlock(match.index, rech.lastIndex, match[2]);\n              }\n            }\n\n            re.lastIndex = ix ? str.length : rech.lastIndex;\n            continue;\n          }\n\n          if (!match[3]) {\n            re.lastIndex = pushQBlock(pos, lastIndex, match[4]);\n            continue;\n          }\n        }\n\n        if (!match[1]) {\n          unescapeStr(str.slice(start, pos));\n          start = re.lastIndex;\n          re = _bp[6 + (isexpr ^= 1)];\n          re.lastIndex = start;\n        }\n      }\n\n      if (str && start < str.length) {\n        unescapeStr(str.slice(start));\n      }\n\n      parts.qblocks = qblocks;\n      return parts;\n\n      function unescapeStr(s) {\n        if (prevStr) {\n          s = prevStr + s;\n          prevStr = '';\n        }\n\n        if (tmpl || isexpr) {\n          parts.push(s && s.replace(_bp[5], '$1'));\n        } else {\n          parts.push(s);\n        }\n      }\n\n      function pushQBlock(_pos, _lastIndex, slash) {\n        //eslint-disable-line\n        if (slash) {\n          _lastIndex = skipRegex(str, _pos);\n        }\n\n        if (tmpl && _lastIndex > _pos + 2) {\n          mark = '\\u2057' + qblocks.length + '~';\n          qblocks.push(str.slice(_pos, _lastIndex));\n          prevStr += str.slice(start, _pos) + mark;\n          start = _lastIndex;\n        }\n\n        return _lastIndex;\n      }\n    };\n\n    _brackets.hasExpr = function hasExpr(str) {\n      return _cache[4].test(str);\n    };\n\n    _brackets.loopKeys = function loopKeys(expr) {\n      var m = expr.match(_cache[9]);\n      return m ? {\n        key: m[1],\n        pos: m[2],\n        val: _cache[0] + m[3].trim() + _cache[1]\n      } : {\n        val: expr.trim()\n      };\n    };\n\n    _brackets.array = function array(pair) {\n      return pair ? _create(pair) : _cache;\n    };\n\n    function _reset(pair) {\n      if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n        _cache = _create(pair);\n        _regex = pair === DEFAULT ? _loopback : _rewrite;\n        _cache[9] = _regex(_pairs[9]);\n      }\n\n      cachedBrackets = pair;\n    }\n\n    function _setSettings(o) {\n      var b;\n      o = o || {};\n      b = o.brackets;\n      Object.defineProperty(o, 'brackets', {\n        set: _reset,\n        get: function () {\n          return cachedBrackets;\n        },\n        enumerable: true\n      });\n      _settings = o;\n\n      _reset(b);\n    }\n\n    Object.defineProperty(_brackets, 'settings', {\n      set: _setSettings,\n      get: function () {\n        return _settings;\n      }\n    });\n    /* istanbul ignore next: in the browser riot is always in the scope */\n\n    _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};\n    _brackets.set = _reset;\n    _brackets.skipRegex = skipRegex;\n    _brackets.R_STRINGS = R_STRINGS;\n    _brackets.R_MLCOMMS = R_MLCOMMS;\n    _brackets.S_QBLOCKS = S_QBLOCKS;\n    _brackets.S_QBLOCK2 = S_QBLOCK2;\n    return _brackets;\n  }();\n  /**\n   * @module tmpl\n   *\n   * tmpl          - Root function, returns the template value, render with data\n   * tmpl.hasExpr  - Test the existence of a expression inside a string\n   * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n   */\n\n  /* istanbul ignore next */\n\n\n  var tmpl = function () {\n    var _cache = {};\n\n    function _tmpl(str, data) {\n      if (!str) {\n        return str;\n      }\n\n      return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr.bind({\n        data: data,\n        tmpl: str\n      }));\n    }\n\n    _tmpl.hasExpr = brackets.hasExpr;\n    _tmpl.loopKeys = brackets.loopKeys; // istanbul ignore next\n\n    _tmpl.clearCache = function () {\n      _cache = {};\n    };\n\n    _tmpl.errorHandler = null;\n\n    function _logErr(err, ctx) {\n      err.riotData = {\n        tagName: ctx && ctx.__ && ctx.__.tagName,\n        _riot_id: ctx && ctx._riot_id //eslint-disable-line camelcase\n\n      };\n\n      if (_tmpl.errorHandler) {\n        _tmpl.errorHandler(err);\n      } else if (typeof console !== 'undefined' && typeof console.error === 'function') {\n        console.error(err.message);\n        console.log('<%s> %s', err.riotData.tagName || 'Unknown tag', this.tmpl); // eslint-disable-line\n\n        console.log(this.data); // eslint-disable-line\n      }\n    }\n\n    function _create(str) {\n      var expr = _getTmpl(str);\n\n      if (expr.slice(0, 11) !== 'try{return ') {\n        expr = 'return ' + expr;\n      }\n\n      return new Function('E', expr + ';'); // eslint-disable-line no-new-func\n    }\n\n    var RE_DQUOTE = /\\u2057/g;\n    var RE_QBMARK = /\\u2057(\\d+)~/g;\n\n    function _getTmpl(str) {\n      var parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1);\n      var qstr = parts.qblocks;\n      var expr;\n\n      if (parts.length > 2 || parts[0]) {\n        var i,\n            j,\n            list = [];\n\n        for (i = j = 0; i < parts.length; ++i) {\n          expr = parts[i];\n\n          if (expr && (expr = i & 1 ? _parseExpr(expr, 1, qstr) : '\"' + expr.replace(/\\\\/g, '\\\\\\\\').replace(/\\r\\n?|\\n/g, '\\\\n').replace(/\"/g, '\\\\\"') + '\"')) {\n            list[j++] = expr;\n          }\n        }\n\n        expr = j < 2 ? list[0] : '[' + list.join(',') + '].join(\"\")';\n      } else {\n        expr = _parseExpr(parts[1], 0, qstr);\n      }\n\n      if (qstr.length) {\n        expr = expr.replace(RE_QBMARK, function (_, pos) {\n          return qstr[pos].replace(/\\r/g, '\\\\r').replace(/\\n/g, '\\\\n');\n        });\n      }\n\n      return expr;\n    }\n\n    var RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/;\n    var RE_BREND = {\n      '(': /[()]/g,\n      '[': /[[\\]]/g,\n      '{': /[{}]/g\n    };\n\n    function _parseExpr(expr, asText, qstr) {\n      expr = expr.replace(/\\s+/g, ' ').trim().replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1');\n\n      if (expr) {\n        var list = [],\n            cnt = 0,\n            match;\n\n        while (expr && (match = expr.match(RE_CSNAME)) && !match.index) {\n          var key,\n              jsb,\n              re = /,|([[{(])|$/g;\n          expr = RegExp.rightContext;\n          key = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1];\n\n          while (jsb = (match = re.exec(expr))[1]) {\n            skipBraces(jsb, re);\n          }\n\n          jsb = expr.slice(0, match.index);\n          expr = RegExp.rightContext;\n          list[cnt++] = _wrapExpr(jsb, 1, key);\n        }\n\n        expr = !cnt ? _wrapExpr(expr, asText) : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0];\n      }\n\n      return expr;\n\n      function skipBraces(ch, re) {\n        var mm,\n            lv = 1,\n            ir = RE_BREND[ch];\n        ir.lastIndex = re.lastIndex;\n\n        while (mm = ir.exec(expr)) {\n          if (mm[0] === ch) {\n            ++lv;\n          } else if (! --lv) {\n            break;\n          }\n        }\n\n        re.lastIndex = lv ? expr.length : ir.lastIndex;\n      }\n    } // istanbul ignore next: not both\n\n\n    var // eslint-disable-next-line max-len\n    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n        JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n        JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/;\n\n    function _wrapExpr(expr, asText, key) {\n      var tb;\n      expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n        if (mvar) {\n          pos = tb ? 0 : pos + match.length;\n\n          if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n            match = p + '(\"' + mvar + JS_CONTEXT + mvar;\n\n            if (pos) {\n              tb = (s = s[pos]) === '.' || s === '(' || s === '[';\n            }\n          } else if (pos) {\n            tb = !JS_NOPROPS.test(s.slice(pos));\n          }\n        }\n\n        return match;\n      });\n\n      if (tb) {\n        expr = 'try{return ' + expr + '}catch(e){E(e,this)}';\n      }\n\n      if (key) {\n        expr = (tb ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')') + '?\"' + key + '\":\"\"';\n      } else if (asText) {\n        expr = 'function(v){' + (tb ? expr.replace('return ', 'v=') : 'v=(' + expr + ')') + ';return v||v===0?v:\"\"}.call(this)';\n      }\n\n      return expr;\n    }\n\n    _tmpl.version = brackets.version = 'v3.0.8';\n    return _tmpl;\n  }();\n  /* istanbul ignore next */\n\n\n  var observable = function (el) {\n    /**\n     * Extend the original object or create a new empty one\n     * @type { Object }\n     */\n    el = el || {};\n    /**\n     * Private variables\n     */\n\n    var callbacks = {},\n        slice = Array.prototype.slice;\n    /**\n     * Public Api\n     */\n    // extend the el object adding the observable methods\n\n    Object.defineProperties(el, {\n      /**\n       * Listen to the given `event` ands\n       * execute the `callback` each time an event is triggered.\n       * @param  { String } event - event id\n       * @param  { Function } fn - callback function\n       * @returns { Object } el\n       */\n      on: {\n        value: function (event, fn) {\n          if (typeof fn == 'function') {\n            (callbacks[event] = callbacks[event] || []).push(fn);\n          }\n\n          return el;\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      },\n\n      /**\n       * Removes the given `event` listeners\n       * @param   { String } event - event id\n       * @param   { Function } fn - callback function\n       * @returns { Object } el\n       */\n      off: {\n        value: function (event, fn) {\n          if (event == '*' && !fn) {\n            callbacks = {};\n          } else {\n            if (fn) {\n              var arr = callbacks[event];\n\n              for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n                if (cb == fn) {\n                  arr.splice(i--, 1);\n                }\n              }\n            } else {\n              delete callbacks[event];\n            }\n          }\n\n          return el;\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      },\n\n      /**\n       * Listen to the given `event` and\n       * execute the `callback` at most once\n       * @param   { String } event - event id\n       * @param   { Function } fn - callback function\n       * @returns { Object } el\n       */\n      one: {\n        value: function (event, fn) {\n          function on() {\n            el.off(event, on);\n            fn.apply(el, arguments);\n          }\n\n          return el.on(event, on);\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      },\n\n      /**\n       * Execute all callback functions that listen to\n       * the given `event`\n       * @param   { String } event - event id\n       * @returns { Object } el\n       */\n      trigger: {\n        value: function (event) {\n          var arguments$1 = arguments; // getting the arguments\n\n          var arglen = arguments.length - 1,\n              args = new Array(arglen),\n              fns,\n              fn,\n              i;\n\n          for (i = 0; i < arglen; i++) {\n            args[i] = arguments$1[i + 1]; // skip first argument\n          }\n\n          fns = slice.call(callbacks[event] || [], 0);\n\n          for (i = 0; fn = fns[i]; ++i) {\n            fn.apply(el, args);\n          }\n\n          if (callbacks['*'] && event != '*') {\n            el.trigger.apply(el, ['*', event].concat(args));\n          }\n\n          return el;\n        },\n        enumerable: false,\n        writable: false,\n        configurable: false\n      }\n    });\n    return el;\n  };\n  /**\n   * Short alias for Object.getOwnPropertyDescriptor\n   */\n\n\n  function getPropDescriptor(o, k) {\n    return Object.getOwnPropertyDescriptor(o, k);\n  }\n  /**\n   * Check if passed argument is undefined\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n\n\n  function isUndefined(value) {\n    return typeof value === T_UNDEF;\n  }\n  /**\n   * Check whether object's property could be overridden\n   * @param   { Object }  obj - source object\n   * @param   { String }  key - object property\n   * @returns { Boolean } true if writable\n   */\n\n\n  function isWritable(obj, key) {\n    var descriptor = getPropDescriptor(obj, key);\n    return isUndefined(obj[key]) || descriptor && descriptor.writable;\n  }\n  /**\n   * Extend any object with other properties\n   * @param   { Object } src - source object\n   * @returns { Object } the resulting extended object\n   *\n   * var obj = { foo: 'baz' }\n   * extend(obj, {bar: 'bar', foo: 'bar'})\n   * console.log(obj) => {bar: 'bar', foo: 'bar'}\n   *\n   */\n\n\n  function extend(src) {\n    var obj;\n    var i = 1;\n    var args = arguments;\n    var l = args.length;\n\n    for (; i < l; i++) {\n      if (obj = args[i]) {\n        for (var key in obj) {\n          // check if this property of the source object could be overridden\n          if (isWritable(src, key)) {\n            src[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    return src;\n  }\n  /**\n   * Alias for Object.create\n   */\n\n\n  function create(src) {\n    return Object.create(src);\n  }\n\n  var settings = extend(create(brackets.settings), {\n    skipAnonymousTags: true,\n    // the \"value\" attributes will be preserved\n    keepValueAttributes: false,\n    // handle the auto updates on any DOM event\n    autoUpdate: true\n  });\n  /**\n   * Shorter and fast way to select multiple nodes in the DOM\n   * @param   { String } selector - DOM selector\n   * @param   { Object } ctx - DOM node where the targets of our search will is located\n   * @returns { Object } dom nodes found\n   */\n\n  function $$(selector, ctx) {\n    return [].slice.call((ctx || document).querySelectorAll(selector));\n  }\n  /**\n   * Create a document text node\n   * @returns { Object } create a text node to use as placeholder\n   */\n\n\n  function createDOMPlaceholder() {\n    return document.createTextNode('');\n  }\n  /**\n   * Toggle the visibility of any DOM node\n   * @param   { Object }  dom - DOM node we want to hide\n   * @param   { Boolean } show - do we want to show it?\n   */\n\n\n  function toggleVisibility(dom, show) {\n    dom.style.display = show ? '' : 'none';\n    dom.hidden = show ? false : true;\n  }\n  /**\n   * Get the value of any DOM attribute on a node\n   * @param   { Object } dom - DOM node we want to parse\n   * @param   { String } name - name of the attribute we want to get\n   * @returns { String | undefined } name of the node attribute whether it exists\n   */\n\n\n  function getAttribute(dom, name) {\n    return dom.getAttribute(name);\n  }\n  /**\n   * Remove any DOM attribute from a node\n   * @param   { Object } dom - DOM node we want to update\n   * @param   { String } name - name of the property we want to remove\n   */\n\n\n  function removeAttribute(dom, name) {\n    dom.removeAttribute(name);\n  }\n  /**\n   * Set the inner html of any DOM node SVGs included\n   * @param { Object } container - DOM node where we'll inject new html\n   * @param { String } html - html to inject\n   * @param { Boolean } isSvg - svg tags should be treated a bit differently\n   */\n\n  /* istanbul ignore next */\n\n\n  function setInnerHTML(container, html, isSvg) {\n    // innerHTML is not supported on svg tags so we neet to treat them differently\n    if (isSvg) {\n      var node = container.ownerDocument.importNode(new DOMParser().parseFromString(\"<svg xmlns=\\\"\" + SVG_NS + \"\\\">\" + html + \"</svg>\", 'application/xml').documentElement, true);\n      container.appendChild(node);\n    } else {\n      container.innerHTML = html;\n    }\n  }\n  /**\n   * Minimize risk: only zero or one _space_ between attr & value\n   * @param   { String }   html - html string we want to parse\n   * @param   { Function } fn - callback function to apply on any attribute found\n   */\n\n\n  function walkAttributes(html, fn) {\n    if (!html) {\n      return;\n    }\n\n    var m;\n\n    while (m = RE_HTML_ATTRS.exec(html)) {\n      fn(m[1].toLowerCase(), m[2] || m[3] || m[4]);\n    }\n  }\n  /**\n   * Create a document fragment\n   * @returns { Object } document fragment\n   */\n\n\n  function createFragment() {\n    return document.createDocumentFragment();\n  }\n  /**\n   * Insert safely a tag to fix #1962 #1649\n   * @param   { HTMLElement } root - children container\n   * @param   { HTMLElement } curr - node to insert\n   * @param   { HTMLElement } next - node that should preceed the current node inserted\n   */\n\n\n  function safeInsert(root, curr, next) {\n    root.insertBefore(curr, next.parentNode && next);\n  }\n  /**\n   * Convert a style object to a string\n   * @param   { Object } style - style object we need to parse\n   * @returns { String } resulting css string\n   * @example\n   * styleObjectToString({ color: 'red', height: '10px'}) // => 'color: red; height: 10px'\n   */\n\n\n  function styleObjectToString(style) {\n    return Object.keys(style).reduce(function (acc, prop) {\n      return acc + \" \" + prop + \": \" + style[prop] + \";\";\n    }, '');\n  }\n  /**\n   * Walk down recursively all the children tags starting dom node\n   * @param   { Object }   dom - starting node where we will start the recursion\n   * @param   { Function } fn - callback to transform the child node just found\n   * @param   { Object }   context - fn can optionally return an object, which is passed to children\n   */\n\n\n  function walkNodes(dom, fn, context) {\n    if (dom) {\n      var res = fn(dom, context);\n      var next; // stop the recursion\n\n      if (res === false) {\n        return;\n      }\n\n      dom = dom.firstChild;\n\n      while (dom) {\n        next = dom.nextSibling;\n        walkNodes(dom, fn, res);\n        dom = next;\n      }\n    }\n  }\n\n  var dom =\n  /*#__PURE__*/\n  Object.freeze({\n    $$: $$,\n    $: $,\n    createDOMPlaceholder: createDOMPlaceholder,\n    mkEl: makeElement,\n    setAttr: setAttribute,\n    toggleVisibility: toggleVisibility,\n    getAttr: getAttribute,\n    remAttr: removeAttribute,\n    setInnerHTML: setInnerHTML,\n    walkAttrs: walkAttributes,\n    createFrag: createFragment,\n    safeInsert: safeInsert,\n    styleObjectToString: styleObjectToString,\n    walkNodes: walkNodes\n  });\n  /**\n   * Check against the null and undefined values\n   * @param   { * }  value -\n   * @returns {Boolean} -\n   */\n\n  function isNil(value) {\n    return isUndefined(value) || value === null;\n  }\n  /**\n   * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank\n   * @param { * } value -\n   * @returns { Boolean } -\n   */\n\n\n  function isBlank(value) {\n    return isNil(value) || value === '';\n  }\n  /**\n   * Check if passed argument is a function\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n\n\n  function isFunction(value) {\n    return typeof value === T_FUNCTION;\n  }\n  /**\n   * Check if passed argument is an object, exclude null\n   * NOTE: use isObject(x) && !isArray(x) to excludes arrays.\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n\n\n  function isObject(value) {\n    return value && typeof value === T_OBJECT; // typeof null is 'object'\n  }\n  /**\n   * Check if a DOM node is an svg tag or part of an svg\n   * @param   { HTMLElement }  el - node we want to test\n   * @returns {Boolean} true if it's an svg node\n   */\n\n\n  function isSvg(el) {\n    var owner = el.ownerSVGElement;\n    return !!owner || owner === null;\n  }\n  /**\n   * Check if passed argument is a kind of array\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n\n\n  function isArray(value) {\n    return Array.isArray(value) || value instanceof Array;\n  }\n  /**\n   * Check if the passed argument is a boolean attribute\n   * @param   { String } value -\n   * @returns { Boolean } -\n   */\n\n\n  function isBoolAttr(value) {\n    return RE_BOOL_ATTRS.test(value);\n  }\n  /**\n   * Check if passed argument is a string\n   * @param   { * } value -\n   * @returns { Boolean } -\n   */\n\n\n  function isString(value) {\n    return typeof value === T_STRING;\n  }\n\n  var check =\n  /*#__PURE__*/\n  Object.freeze({\n    isBlank: isBlank,\n    isFunction: isFunction,\n    isObject: isObject,\n    isSvg: isSvg,\n    isWritable: isWritable,\n    isArray: isArray,\n    isBoolAttr: isBoolAttr,\n    isNil: isNil,\n    isString: isString,\n    isUndefined: isUndefined\n  });\n  /**\n   * Check whether an array contains an item\n   * @param   { Array } array - target array\n   * @param   { * } item - item to test\n   * @returns { Boolean } -\n   */\n\n  function contains(array, item) {\n    return array.indexOf(item) !== -1;\n  }\n  /**\n   * Specialized function for looping an array-like collection with `each={}`\n   * @param   { Array } list - collection of items\n   * @param   {Function} fn - callback function\n   * @returns { Array } the array looped\n   */\n\n\n  function each(list, fn) {\n    var len = list ? list.length : 0;\n    var i = 0;\n\n    for (; i < len; i++) {\n      fn(list[i], i);\n    }\n\n    return list;\n  }\n  /**\n   * Faster String startsWith alternative\n   * @param   { String } str - source string\n   * @param   { String } value - test string\n   * @returns { Boolean } -\n   */\n\n\n  function startsWith(str, value) {\n    return str.slice(0, value.length) === value;\n  }\n  /**\n   * Function returning always a unique identifier\n   * @returns { Number } - number from 0...n\n   */\n\n\n  var uid = function uid() {\n    var i = -1;\n    return function () {\n      return ++i;\n    };\n  }();\n  /**\n   * Helper function to set an immutable property\n   * @param   { Object } el - object where the new property will be set\n   * @param   { String } key - object key where the new property will be stored\n   * @param   { * } value - value of the new property\n   * @param   { Object } options - set the propery overriding the default options\n   * @returns { Object } - the initial object\n   */\n\n\n  function define(el, key, value, options) {\n    Object.defineProperty(el, key, extend({\n      value: value,\n      enumerable: false,\n      writable: false,\n      configurable: true\n    }, options));\n    return el;\n  }\n  /**\n   * Convert a string containing dashes to camel case\n   * @param   { String } str - input string\n   * @returns { String } my-string -> myString\n   */\n\n\n  function toCamel(str) {\n    return str.replace(/-(\\w)/g, function (_, c) {\n      return c.toUpperCase();\n    });\n  }\n  /**\n   * Warn a message via console\n   * @param   {String} message - warning message\n   */\n\n\n  function warn(message) {\n    if (console && console.warn) {\n      console.warn(message);\n    }\n  }\n\n  var misc =\n  /*#__PURE__*/\n  Object.freeze({\n    contains: contains,\n    each: each,\n    getPropDescriptor: getPropDescriptor,\n    startsWith: startsWith,\n    uid: uid,\n    defineProperty: define,\n    objectCreate: create,\n    extend: extend,\n    toCamel: toCamel,\n    warn: warn\n  });\n  /**\n   * Set the property of an object for a given key. If something already\n   * exists there, then it becomes an array containing both the old and new value.\n   * @param { Object } obj - object on which to set the property\n   * @param { String } key - property name\n   * @param { Object } value - the value of the property to be set\n   * @param { Boolean } ensureArray - ensure that the property remains an array\n   * @param { Number } index - add the new item in a certain array position\n   */\n\n  function arrayishAdd(obj, key, value, ensureArray, index) {\n    var dest = obj[key];\n    var isArr = isArray(dest);\n    var hasIndex = !isUndefined(index);\n\n    if (dest && dest === value) {\n      return;\n    } // if the key was never set, set it once\n\n\n    if (!dest && ensureArray) {\n      obj[key] = [value];\n    } else if (!dest) {\n      obj[key] = value;\n    } // if it was an array and not yet set\n    else {\n        if (isArr) {\n          var oldIndex = dest.indexOf(value); // this item never changed its position\n\n          if (oldIndex === index) {\n            return;\n          } // remove the item from its old position\n\n\n          if (oldIndex !== -1) {\n            dest.splice(oldIndex, 1);\n          } // move or add the item\n\n\n          if (hasIndex) {\n            dest.splice(index, 0, value);\n          } else {\n            dest.push(value);\n          }\n        } else {\n          obj[key] = [dest, value];\n        }\n      }\n  }\n  /**\n   * Detect the tag implementation by a DOM node\n   * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n   * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n   */\n\n\n  function get(dom) {\n    return dom.tagName && __TAG_IMPL[getAttribute(dom, IS_DIRECTIVE) || getAttribute(dom, IS_DIRECTIVE) || dom.tagName.toLowerCase()];\n  }\n  /**\n   * Get the tag name of any DOM node\n   * @param   { Object } dom - DOM node we want to parse\n   * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent\n   * @returns { String } name to identify this dom node in riot\n   */\n\n\n  function getName(dom, skipDataIs) {\n    var child = get(dom);\n    var namedTag = !skipDataIs && getAttribute(dom, IS_DIRECTIVE);\n    return namedTag && !tmpl.hasExpr(namedTag) ? namedTag : child ? child.name : dom.tagName.toLowerCase();\n  }\n  /**\n   * Return a temporary context containing also the parent properties\n   * @this Tag\n   * @param { Tag } - temporary tag context containing all the parent properties\n   */\n\n\n  function inheritParentProps() {\n    if (this.parent) {\n      return extend(create(this), this.parent);\n    }\n\n    return this;\n  }\n  /*\n    Includes hacks needed for the Internet Explorer version 9 and below\n    See: http://kangax.github.io/compat-table/es5/#ie8\n         http://codeplanet.io/dropping-ie8/\n  */\n\n\n  var reHasYield = /<yield\\b/i,\n      reYieldAll = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig,\n      reYieldSrc = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig,\n      reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig,\n      rootEls = {\n    tr: 'tbody',\n    th: 'tr',\n    td: 'tr',\n    col: 'colgroup'\n  },\n      tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION,\n      GENERIC = 'div',\n      SVG = 'svg';\n  /*\n    Creates the root element for table or select child elements:\n    tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n  */\n\n  function specialTags(el, tmpl, tagName) {\n    var select = tagName[0] === 'o',\n        parent = select ? 'select>' : 'table>'; // trim() is important here, this ensures we don't have artifacts,\n    // so we can check if we have only one element inside the parent\n\n    el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;\n    parent = el.firstChild; // returns the immediate parent if tr/th/td/col is the only element, if not\n    // returns the whole tree, as this can include additional elements\n\n    /* istanbul ignore next */\n\n    if (select) {\n      parent.selectedIndex = -1; // for IE9, compatible w/current riot behavior\n    } else {\n      // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n      var tname = rootEls[tagName];\n\n      if (tname && parent.childElementCount === 1) {\n        parent = $(tname, parent);\n      }\n    }\n\n    return parent;\n  }\n  /*\n    Replace the yield tag from any tag template with the innerHTML of the\n    original tag in the page\n  */\n\n\n  function replaceYield(tmpl, html) {\n    // do nothing if no yield\n    if (!reHasYield.test(tmpl)) {\n      return tmpl;\n    } // be careful with #1343 - string on the source having `$1`\n\n\n    var src = {};\n    html = html && html.replace(reYieldSrc, function (_, ref, text) {\n      src[ref] = src[ref] || text; // preserve first definition\n\n      return '';\n    }).trim();\n    return tmpl.replace(reYieldDest, function (_, ref, def) {\n      // yield with from - to attrs\n      return src[ref] || def || '';\n    }).replace(reYieldAll, function (_, def) {\n      // yield without any \"from\"\n      return html || def || '';\n    });\n  }\n  /**\n   * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n   * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n   *\n   * @param   { String } tmpl  - The template coming from the custom tag definition\n   * @param   { String } html - HTML content that comes from the DOM element where you\n   *           will mount the tag, mostly the original tag in the page\n   * @param   { Boolean } isSvg - true if the root node is an svg\n   * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.\n   */\n\n\n  function mkdom(tmpl, html, isSvg) {\n    var match = tmpl && tmpl.match(/^\\s*<([-\\w]+)/);\n    var tagName = match && match[1].toLowerCase();\n    var el = makeElement(isSvg ? SVG : GENERIC); // replace all the yield tags with the tag inner html\n\n    tmpl = replaceYield(tmpl, html);\n    /* istanbul ignore next */\n\n    if (tblTags.test(tagName)) {\n      el = specialTags(el, tmpl, tagName);\n    } else {\n      setInnerHTML(el, tmpl, isSvg);\n    }\n\n    return el;\n  }\n\n  var EVENT_ATTR_RE = /^on/;\n  /**\n   * True if the event attribute starts with 'on'\n   * @param   { String } attribute - event attribute\n   * @returns { Boolean }\n   */\n\n  function isEventAttribute(attribute) {\n    return EVENT_ATTR_RE.test(attribute);\n  }\n  /**\n   * Loop backward all the parents tree to detect the first custom parent tag\n   * @param   { Object } tag - a Tag instance\n   * @returns { Object } the instance of the first custom parent tag found\n   */\n\n\n  function getImmediateCustomParent(tag) {\n    var ptag = tag;\n\n    while (ptag.__.isAnonymous) {\n      if (!ptag.parent) {\n        break;\n      }\n\n      ptag = ptag.parent;\n    }\n\n    return ptag;\n  }\n  /**\n   * Trigger DOM events\n   * @param   { HTMLElement } dom - dom element target of the event\n   * @param   { Function } handler - user function\n   * @param   { Object } e - event object\n   */\n\n\n  function handleEvent(dom, handler, e) {\n    var ptag = this.__.parent;\n    var item = this.__.item;\n\n    if (!item) {\n      while (ptag && !item) {\n        item = ptag.__.item;\n        ptag = ptag.__.parent;\n      }\n    } // override the event properties\n\n    /* istanbul ignore next */\n\n\n    if (isWritable(e, 'currentTarget')) {\n      e.currentTarget = dom;\n    }\n    /* istanbul ignore next */\n\n\n    if (isWritable(e, 'target')) {\n      e.target = e.srcElement;\n    }\n    /* istanbul ignore next */\n\n\n    if (isWritable(e, 'which')) {\n      e.which = e.charCode || e.keyCode;\n    }\n\n    e.item = item;\n    handler.call(this, e); // avoid auto updates\n\n    if (!settings.autoUpdate) {\n      return;\n    }\n\n    if (!e.preventUpdate) {\n      var p = getImmediateCustomParent(this); // fixes #2083\n\n      if (p.isMounted) {\n        p.update();\n      }\n    }\n  }\n  /**\n   * Attach an event to a DOM node\n   * @param { String } name - event name\n   * @param { Function } handler - event callback\n   * @param { Object } dom - dom node\n   * @param { Tag } tag - tag instance\n   */\n\n\n  function setEventHandler(name, handler, dom, tag) {\n    var eventName;\n    var cb = handleEvent.bind(tag, dom, handler); // avoid to bind twice the same event\n    // possible fix for #2332\n\n    dom[name] = null; // normalize event name\n\n    eventName = name.replace(RE_EVENTS_PREFIX, ''); // cache the listener into the listeners array\n\n    if (!contains(tag.__.listeners, dom)) {\n      tag.__.listeners.push(dom);\n    }\n\n    if (!dom[RIOT_EVENTS_KEY]) {\n      dom[RIOT_EVENTS_KEY] = {};\n    }\n\n    if (dom[RIOT_EVENTS_KEY][name]) {\n      dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][name]);\n    }\n\n    dom[RIOT_EVENTS_KEY][name] = cb;\n    dom.addEventListener(eventName, cb, false);\n  }\n  /**\n   * Create a new child tag including it correctly into its parent\n   * @param   { Object } child - child tag implementation\n   * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n   * @param   { String } innerHTML - inner html of the child node\n   * @param   { Object } parent - instance of the parent tag including the child custom tag\n   * @returns { Object } instance of the new child tag just created\n   */\n\n\n  function initChild(child, opts, innerHTML, parent) {\n    var tag = createTag(child, opts, innerHTML);\n    var tagName = opts.tagName || getName(opts.root, true);\n    var ptag = getImmediateCustomParent(parent); // fix for the parent attribute in the looped elements\n\n    define(tag, 'parent', ptag); // store the real parent tag\n    // in some cases this could be different from the custom parent tag\n    // for example in nested loops\n\n    tag.__.parent = parent; // add this tag to the custom parent tag\n\n    arrayishAdd(ptag.tags, tagName, tag); // and also to the real parent tag\n\n    if (ptag !== parent) {\n      arrayishAdd(parent.tags, tagName, tag);\n    }\n\n    return tag;\n  }\n  /**\n   * Removes an item from an object at a given key. If the key points to an array,\n   * then the item is just removed from the array.\n   * @param { Object } obj - object on which to remove the property\n   * @param { String } key - property name\n   * @param { Object } value - the value of the property to be removed\n   * @param { Boolean } ensureArray - ensure that the property remains an array\n  */\n\n\n  function arrayishRemove(obj, key, value, ensureArray) {\n    if (isArray(obj[key])) {\n      var index = obj[key].indexOf(value);\n\n      if (index !== -1) {\n        obj[key].splice(index, 1);\n      }\n\n      if (!obj[key].length) {\n        delete obj[key];\n      } else if (obj[key].length === 1 && !ensureArray) {\n        obj[key] = obj[key][0];\n      }\n    } else if (obj[key] === value) {\n      delete obj[key];\n    } // otherwise just delete the key\n\n  }\n  /**\n   * Adds the elements for a virtual tag\n   * @this Tag\n   * @param { Node } src - the node that will do the inserting or appending\n   * @param { Tag } target - only if inserting, insert before this tag's first child\n   */\n\n\n  function makeVirtual(src, target) {\n    var this$1 = this;\n    var head = createDOMPlaceholder();\n    var tail = createDOMPlaceholder();\n    var frag = createFragment();\n    var sib;\n    var el;\n    this.root.insertBefore(head, this.root.firstChild);\n    this.root.appendChild(tail);\n    this.__.head = el = head;\n    this.__.tail = tail;\n\n    while (el) {\n      sib = el.nextSibling;\n      frag.appendChild(el);\n\n      this$1.__.virts.push(el); // hold for unmounting\n\n\n      el = sib;\n    }\n\n    if (target) {\n      src.insertBefore(frag, target.__.head);\n    } else {\n      src.appendChild(frag);\n    }\n  }\n  /**\n   * makes a tag virtual and replaces a reference in the dom\n   * @this Tag\n   * @param { tag } the tag to make virtual\n   * @param { ref } the dom reference location\n   */\n\n\n  function makeReplaceVirtual(tag, ref) {\n    if (!ref.parentNode) {\n      return;\n    }\n\n    var frag = createFragment();\n    makeVirtual.call(tag, frag);\n    ref.parentNode.replaceChild(frag, ref);\n  }\n  /**\n   * Update dynamically created data-is tags with changing expressions\n   * @param { Object } expr - expression tag and expression info\n   * @param { Tag }    parent - parent for tag creation\n   * @param { String } tagName - tag implementation we want to use\n   */\n\n\n  function updateDataIs(expr, parent, tagName) {\n    var tag = expr.tag || expr.dom._tag;\n    var ref;\n    var ref$1 = tag ? tag.__ : {};\n    var head = ref$1.head;\n    var isVirtual = expr.dom.tagName === 'VIRTUAL';\n\n    if (tag && expr.tagName === tagName) {\n      tag.update();\n      return;\n    } // sync _parent to accommodate changing tagnames\n\n\n    if (tag) {\n      // need placeholder before unmount\n      if (isVirtual) {\n        ref = createDOMPlaceholder();\n        head.parentNode.insertBefore(ref, head);\n      }\n\n      tag.unmount(true);\n    } // unable to get the tag name\n\n\n    if (!isString(tagName)) {\n      return;\n    }\n\n    expr.impl = __TAG_IMPL[tagName]; // unknown implementation\n\n    if (!expr.impl) {\n      return;\n    }\n\n    expr.tag = tag = initChild(expr.impl, {\n      root: expr.dom,\n      parent: parent,\n      tagName: tagName\n    }, expr.dom.innerHTML, parent);\n    each(expr.attrs, function (a) {\n      return setAttribute(tag.root, a.name, a.value);\n    });\n    expr.tagName = tagName;\n    tag.mount(); // root exist first time, after use placeholder\n\n    if (isVirtual) {\n      makeReplaceVirtual(tag, ref || tag.root);\n    } // parent is the placeholder tag, not the dynamic tag so clean up\n\n\n    parent.__.onUnmount = function () {\n      var delName = tag.opts.dataIs;\n      arrayishRemove(tag.parent.tags, delName, tag);\n      arrayishRemove(tag.__.parent.tags, delName, tag);\n      tag.unmount();\n    };\n  }\n  /**\n   * Nomalize any attribute removing the \"riot-\" prefix\n   * @param   { String } attrName - original attribute name\n   * @returns { String } valid html attribute name\n   */\n\n\n  function normalizeAttrName(attrName) {\n    if (!attrName) {\n      return null;\n    }\n\n    attrName = attrName.replace(ATTRS_PREFIX, '');\n\n    if (CASE_SENSITIVE_ATTRIBUTES[attrName]) {\n      attrName = CASE_SENSITIVE_ATTRIBUTES[attrName];\n    }\n\n    return attrName;\n  }\n  /**\n   * Update on single tag expression\n   * @this Tag\n   * @param { Object } expr - expression logic\n   * @returns { undefined }\n   */\n\n\n  function updateExpression(expr) {\n    if (this.root && getAttribute(this.root, 'virtualized')) {\n      return;\n    }\n\n    var dom = expr.dom; // remove the riot- prefix\n\n    var attrName = normalizeAttrName(expr.attr);\n    var isToggle = contains([SHOW_DIRECTIVE, HIDE_DIRECTIVE], attrName);\n    var isVirtual = expr.root && expr.root.tagName === 'VIRTUAL';\n    var ref = this.__;\n    var isAnonymous = ref.isAnonymous;\n    var parent = dom && (expr.parent || dom.parentNode);\n    var keepValueAttributes = settings.keepValueAttributes; // detect the style attributes\n\n    var isStyleAttr = attrName === 'style';\n    var isClassAttr = attrName === 'class';\n    var isValueAttr = attrName === 'value';\n    var value; // if it's a tag we could totally skip the rest\n\n    if (expr._riot_id) {\n      if (expr.__.wasCreated) {\n        expr.update(); // if it hasn't been mounted yet, do that now.\n      } else {\n        expr.mount();\n\n        if (isVirtual) {\n          makeReplaceVirtual(expr, expr.root);\n        }\n      }\n\n      return;\n    } // if this expression has the update method it means it can handle the DOM changes by itself\n\n\n    if (expr.update) {\n      return expr.update();\n    }\n\n    var context = isToggle && !isAnonymous ? inheritParentProps.call(this) : this; // ...it seems to be a simple expression so we try to calculate its value\n\n    value = tmpl(expr.expr, context);\n    var hasValue = !isBlank(value);\n    var isObj = isObject(value); // convert the style/class objects to strings\n\n    if (isObj) {\n      if (isClassAttr) {\n        value = tmpl(JSON.stringify(value), this);\n      } else if (isStyleAttr) {\n        value = styleObjectToString(value);\n      }\n    } // remove original attribute\n\n\n    if (expr.attr && ( // the original attribute can be removed only if we are parsing the original expression\n    !expr.wasParsedOnce || // or its value is false\n    value === false || // or if its value is currently falsy...\n    // We will keep the \"value\" attributes if the \"keepValueAttributes\"\n    // is enabled though\n    !hasValue && (!isValueAttr || isValueAttr && !keepValueAttributes))) {\n      // remove either riot-* attributes or just the attribute name\n      removeAttribute(dom, getAttribute(dom, expr.attr) ? expr.attr : attrName);\n    } // for the boolean attributes we don't need the value\n    // we can convert it to checked=true to checked=checked\n\n\n    if (expr.bool) {\n      value = value ? attrName : false;\n    }\n\n    if (expr.isRtag) {\n      return updateDataIs(expr, this, value);\n    }\n\n    if (expr.wasParsedOnce && expr.value === value) {\n      return;\n    } // update the expression value\n\n\n    expr.value = value;\n    expr.wasParsedOnce = true; // if the value is an object (and it's not a style or class attribute) we can not do much more with it\n\n    if (isObj && !isClassAttr && !isStyleAttr && !isToggle) {\n      return;\n    } // avoid to render undefined/null values\n\n\n    if (!hasValue) {\n      value = '';\n    } // textarea and text nodes have no attribute name\n\n\n    if (!attrName) {\n      // about #815 w/o replace: the browser converts the value to a string,\n      // the comparison by \"==\" does too, but not in the server\n      value += ''; // test for parent avoids error with invalid assignment to nodeValue\n\n      if (parent) {\n        // cache the parent node because somehow it will become null on IE\n        // on the next iteration\n        expr.parent = parent;\n\n        if (parent.tagName === 'TEXTAREA') {\n          parent.value = value; // #1113\n\n          if (!IE_VERSION) {\n            dom.nodeValue = value;\n          } // #1625 IE throws here, nodeValue\n\n        } // will be available on 'updated'\n        else {\n            dom.nodeValue = value;\n          }\n      }\n\n      return;\n    }\n\n    switch (true) {\n      // handle events binding\n      case isFunction(value):\n        if (isEventAttribute(attrName)) {\n          setEventHandler(attrName, value, dom, this);\n        }\n\n        break;\n      // show / hide\n\n      case isToggle:\n        toggleVisibility(dom, attrName === HIDE_DIRECTIVE ? !value : value);\n        break;\n      // handle attributes\n\n      default:\n        if (expr.bool) {\n          dom[attrName] = value;\n        }\n\n        if (isValueAttr && dom.value !== value) {\n          dom.value = value;\n        } else if (hasValue && value !== false) {\n          setAttribute(dom, attrName, value);\n        } // make sure that in case of style changes\n        // the element stays hidden\n\n\n        if (isStyleAttr && dom.hidden) {\n          toggleVisibility(dom, false);\n        }\n\n    }\n  }\n  /**\n   * Update all the expressions in a Tag instance\n   * @this Tag\n   * @param { Array } expressions - expression that must be re evaluated\n   */\n\n\n  function update(expressions) {\n    each(expressions, updateExpression.bind(this));\n  }\n  /**\n   * We need to update opts for this tag. That requires updating the expressions\n   * in any attributes on the tag, and then copying the result onto opts.\n   * @this Tag\n   * @param   {Boolean} isLoop - is it a loop tag?\n   * @param   { Tag }  parent - parent tag node\n   * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)\n   * @param   { Object }  opts - tag options\n   * @param   { Array }  instAttrs - tag attributes array\n   */\n\n\n  function updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {\n    // isAnonymous `each` tags treat `dom` and `root` differently. In this case\n    // (and only this case) we don't need to do updateOpts, because the regular parse\n    // will update those attrs. Plus, isAnonymous tags don't need opts anyway\n    if (isLoop && isAnonymous) {\n      return;\n    }\n\n    var ctx = isLoop ? inheritParentProps.call(this) : parent || this;\n    each(instAttrs, function (attr) {\n      if (attr.expr) {\n        updateExpression.call(ctx, attr.expr);\n      } // normalize the attribute names\n\n\n      opts[toCamel(attr.name).replace(ATTRS_PREFIX, '')] = attr.expr ? attr.expr.value : attr.value;\n    });\n  }\n  /**\n   * Update the tag expressions and options\n   * @param { Tag } tag - tag object\n   * @param { * } data - data we want to use to extend the tag properties\n   * @param { Array } expressions - component expressions array\n   * @returns { Tag } the current tag instance\n   */\n\n\n  function componentUpdate(tag, data, expressions) {\n    var __ = tag.__;\n    var nextOpts = {};\n    var canTrigger = tag.isMounted && !__.skipAnonymous; // inherit properties from the parent tag\n\n    if (__.isAnonymous && __.parent) {\n      extend(tag, __.parent);\n    }\n\n    extend(tag, data);\n    updateOpts.apply(tag, [__.isLoop, __.parent, __.isAnonymous, nextOpts, __.instAttrs]);\n\n    if (canTrigger && tag.isMounted && isFunction(tag.shouldUpdate) && !tag.shouldUpdate(data, nextOpts)) {\n      return tag;\n    }\n\n    extend(tag.opts, nextOpts);\n\n    if (canTrigger) {\n      tag.trigger('update', data);\n    }\n\n    update.call(tag, expressions);\n\n    if (canTrigger) {\n      tag.trigger('updated');\n    }\n\n    return tag;\n  }\n  /**\n   * Get selectors for tags\n   * @param   { Array } tags - tag names to select\n   * @returns { String } selector\n   */\n\n\n  function query(tags) {\n    // select all tags\n    if (!tags) {\n      var keys = Object.keys(__TAG_IMPL);\n      return keys + query(keys);\n    }\n\n    return tags.filter(function (t) {\n      return !/[^-\\w]/.test(t);\n    }).reduce(function (list, t) {\n      var name = t.trim().toLowerCase();\n      return list + \",[\" + IS_DIRECTIVE + \"=\\\"\" + name + \"\\\"]\";\n    }, '');\n  }\n  /**\n   * Another way to create a riot tag a bit more es6 friendly\n   * @param { HTMLElement } el - tag DOM selector or DOM node/s\n   * @param { Object } opts - tag logic\n   * @returns { Tag } new riot tag instance\n   */\n\n\n  function Tag(el, opts) {\n    // get the tag properties from the class constructor\n    var ref = this;\n    var name = ref.name;\n    var tmpl = ref.tmpl;\n    var css = ref.css;\n    var attrs = ref.attrs;\n    var onCreate = ref.onCreate; // register a new tag and cache the class prototype\n\n    if (!__TAG_IMPL[name]) {\n      tag(name, tmpl, css, attrs, onCreate); // cache the class constructor\n\n      __TAG_IMPL[name].class = this.constructor;\n    } // mount the tag using the class instance\n\n\n    mount$1(el, name, opts, this); // inject the component css\n\n    if (css) {\n      styleManager.inject();\n    }\n\n    return this;\n  }\n  /**\n   * Create a new riot tag implementation\n   * @param   { String }   name - name/id of the new riot tag\n   * @param   { String }   tmpl - tag template\n   * @param   { String }   css - custom tag css\n   * @param   { String }   attrs - root tag attributes\n   * @param   { Function } fn - user function\n   * @returns { String } name/id of the tag just created\n   */\n\n\n  function tag(name, tmpl, css, attrs, fn) {\n    if (isFunction(attrs)) {\n      fn = attrs;\n\n      if (/^[\\w-]+\\s?=/.test(css)) {\n        attrs = css;\n        css = '';\n      } else {\n        attrs = '';\n      }\n    }\n\n    if (css) {\n      if (isFunction(css)) {\n        fn = css;\n      } else {\n        styleManager.add(css, name);\n      }\n    }\n\n    name = name.toLowerCase();\n    __TAG_IMPL[name] = {\n      name: name,\n      tmpl: tmpl,\n      attrs: attrs,\n      fn: fn\n    };\n    return name;\n  }\n  /**\n   * Create a new riot tag implementation (for use by the compiler)\n   * @param   { String }   name - name/id of the new riot tag\n   * @param   { String }   tmpl - tag template\n   * @param   { String }   css - custom tag css\n   * @param   { String }   attrs - root tag attributes\n   * @param   { Function } fn - user function\n   * @returns { String } name/id of the tag just created\n   */\n\n\n  function tag2(name, tmpl, css, attrs, fn) {\n    if (css) {\n      styleManager.add(css, name);\n    }\n\n    __TAG_IMPL[name] = {\n      name: name,\n      tmpl: tmpl,\n      attrs: attrs,\n      fn: fn\n    };\n    return name;\n  }\n  /**\n   * Mount a tag using a specific tag implementation\n   * @param   { * } selector - tag DOM selector or DOM node/s\n   * @param   { String } tagName - tag implementation name\n   * @param   { Object } opts - tag logic\n   * @returns { Array } new tags instances\n   */\n\n\n  function mount(selector, tagName, opts) {\n    var tags = [];\n    var elem, allTags;\n\n    function pushTagsTo(root) {\n      if (root.tagName) {\n        var riotTag = getAttribute(root, IS_DIRECTIVE),\n            tag; // have tagName? force riot-tag to be the same\n\n        if (tagName && riotTag !== tagName) {\n          riotTag = tagName;\n          setAttribute(root, IS_DIRECTIVE, tagName);\n        }\n\n        tag = mount$1(root, riotTag || root.tagName.toLowerCase(), isFunction(opts) ? opts() : opts);\n\n        if (tag) {\n          tags.push(tag);\n        }\n      } else if (root.length) {\n        each(root, pushTagsTo);\n      } // assume nodeList\n\n    } // inject styles into DOM\n\n\n    styleManager.inject();\n\n    if (isObject(tagName) || isFunction(tagName)) {\n      opts = tagName;\n      tagName = 0;\n    } // crawl the DOM to find the tag\n\n\n    if (isString(selector)) {\n      selector = selector === '*' ? // select all registered tags\n      // & tags found with the riot-tag attribute set\n      allTags = query() : // or just the ones named like the selector\n      selector + query(selector.split(/, */)); // make sure to pass always a selector\n      // to the querySelectorAll function\n\n      elem = selector ? $$(selector) : [];\n    } else // probably you have passed already a tag or a NodeList\n      {\n        elem = selector;\n      } // select all the registered and mount them inside their root elements\n\n\n    if (tagName === '*') {\n      // get all custom tags\n      tagName = allTags || query(); // if the root els it's just a single tag\n\n      if (elem.tagName) {\n        elem = $$(tagName, elem);\n      } else {\n        // select all the children for all the different root elements\n        var nodeList = [];\n        each(elem, function (_el) {\n          return nodeList.push($$(tagName, _el));\n        });\n        elem = nodeList;\n      } // get rid of the tagName\n\n\n      tagName = 0;\n    }\n\n    pushTagsTo(elem);\n    return tags;\n  } // Create a mixin that could be globally shared across all the tags\n\n\n  var mixins = {};\n  var globals = mixins[GLOBAL_MIXIN] = {};\n  var mixins_id = 0;\n  /**\n   * Create/Return a mixin by its name\n   * @param   { String }  name - mixin name (global mixin if object)\n   * @param   { Object }  mix - mixin logic\n   * @param   { Boolean } g - is global?\n   * @returns { Object }  the mixin logic\n   */\n\n  function mixin(name, mix, g) {\n    // Unnamed global\n    if (isObject(name)) {\n      mixin(\"__\" + mixins_id++ + \"__\", name, true);\n      return;\n    }\n\n    var store = g ? globals : mixins; // Getter\n\n    if (!mix) {\n      if (isUndefined(store[name])) {\n        throw new Error(\"Unregistered mixin: \" + name);\n      }\n\n      return store[name];\n    } // Setter\n\n\n    store[name] = isFunction(mix) ? extend(mix.prototype, store[name] || {}) && mix : extend(store[name] || {}, mix);\n  }\n  /**\n   * Update all the tags instances created\n   * @returns { Array } all the tags instances\n   */\n\n\n  function update$1() {\n    return each(__TAGS_CACHE, function (tag) {\n      return tag.update();\n    });\n  }\n\n  function unregister(name) {\n    styleManager.remove(name);\n    return delete __TAG_IMPL[name];\n  }\n\n  var version = 'v3.13.2';\n  var core =\n  /*#__PURE__*/\n  Object.freeze({\n    Tag: Tag,\n    tag: tag,\n    tag2: tag2,\n    mount: mount,\n    mixin: mixin,\n    update: update$1,\n    unregister: unregister,\n    version: version\n  });\n  /**\n   * Add a mixin to this tag\n   * @returns { Tag } the current tag instance\n   */\n\n  function componentMixin(tag$$1) {\n    var mixins = [],\n        len = arguments.length - 1;\n\n    while (len-- > 0) mixins[len] = arguments[len + 1];\n\n    each(mixins, function (mix) {\n      var instance;\n      var obj;\n      var props = []; // properties blacklisted and will not be bound to the tag instance\n\n      var propsBlacklist = ['init', '__proto__'];\n      mix = isString(mix) ? mixin(mix) : mix; // check if the mixin is a function\n\n      if (isFunction(mix)) {\n        // create the new mixin instance\n        instance = new mix();\n      } else {\n        instance = mix;\n      }\n\n      var proto = Object.getPrototypeOf(instance); // build multilevel prototype inheritance chain property list\n\n      do {\n        props = props.concat(Object.getOwnPropertyNames(obj || instance));\n      } while (obj = Object.getPrototypeOf(obj || instance)); // loop the keys in the function prototype or the all object keys\n\n\n      each(props, function (key) {\n        // bind methods to tag\n        // allow mixins to override other properties/parent mixins\n        if (!contains(propsBlacklist, key)) {\n          // check for getters/setters\n          var descriptor = getPropDescriptor(instance, key) || getPropDescriptor(proto, key);\n          var hasGetterSetter = descriptor && (descriptor.get || descriptor.set); // apply method only if it does not already exist on the instance\n\n          if (!tag$$1.hasOwnProperty(key) && hasGetterSetter) {\n            Object.defineProperty(tag$$1, key, descriptor);\n          } else {\n            tag$$1[key] = isFunction(instance[key]) ? instance[key].bind(tag$$1) : instance[key];\n          }\n        }\n      }); // init method will be called automatically\n\n      if (instance.init) {\n        instance.init.bind(tag$$1)(tag$$1.opts);\n      }\n    });\n    return tag$$1;\n  }\n  /**\n   * Move the position of a custom tag in its parent tag\n   * @this Tag\n   * @param   { String } tagName - key where the tag was stored\n   * @param   { Number } newPos - index where the new tag will be stored\n   */\n\n\n  function moveChild(tagName, newPos) {\n    var parent = this.parent;\n    var tags; // no parent no move\n\n    if (!parent) {\n      return;\n    }\n\n    tags = parent.tags[tagName];\n\n    if (isArray(tags)) {\n      tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]);\n    } else {\n      arrayishAdd(parent.tags, tagName, this);\n    }\n  }\n  /**\n   * Move virtual tag and all child nodes\n   * @this Tag\n   * @param { Node } src  - the node that will do the inserting\n   * @param { Tag } target - insert before this tag's first child\n   */\n\n\n  function moveVirtual(src, target) {\n    var this$1 = this;\n    var el = this.__.head;\n    var sib;\n    var frag = createFragment();\n\n    while (el) {\n      sib = el.nextSibling;\n      frag.appendChild(el);\n      el = sib;\n\n      if (el === this$1.__.tail) {\n        frag.appendChild(el);\n        src.insertBefore(frag, target.__.head);\n        break;\n      }\n    }\n  }\n  /**\n   * Convert the item looped into an object used to extend the child tag properties\n   * @param   { Object } expr - object containing the keys used to extend the children tags\n   * @param   { * } key - value to assign to the new object returned\n   * @param   { * } val - value containing the position of the item in the array\n   * @returns { Object } - new object containing the values of the original item\n   *\n   * The variables 'key' and 'val' are arbitrary.\n   * They depend on the collection type looped (Array, Object)\n   * and on the expression used on the each tag\n   *\n   */\n\n\n  function mkitem(expr, key, val) {\n    var item = {};\n    item[expr.key] = key;\n\n    if (expr.pos) {\n      item[expr.pos] = val;\n    }\n\n    return item;\n  }\n  /**\n   * Unmount the redundant tags\n   * @param   { Array } items - array containing the current items to loop\n   * @param   { Array } tags - array containing all the children tags\n   */\n\n\n  function unmountRedundant(items, tags, filteredItemsCount) {\n    var i = tags.length;\n    var j = items.length - filteredItemsCount;\n\n    while (i > j) {\n      i--;\n      remove.apply(tags[i], [tags, i]);\n    }\n  }\n  /**\n   * Remove a child tag\n   * @this Tag\n   * @param   { Array } tags - tags collection\n   * @param   { Number } i - index of the tag to remove\n   */\n\n\n  function remove(tags, i) {\n    tags.splice(i, 1);\n    this.unmount();\n    arrayishRemove(this.parent, this, this.__.tagName, true);\n  }\n  /**\n   * Move the nested custom tags in non custom loop tags\n   * @this Tag\n   * @param   { Number } i - current position of the loop tag\n   */\n\n\n  function moveNestedTags(i) {\n    var this$1 = this;\n    each(Object.keys(this.tags), function (tagName) {\n      moveChild.apply(this$1.tags[tagName], [tagName, i]);\n    });\n  }\n  /**\n   * Move a child tag\n   * @this Tag\n   * @param   { HTMLElement } root - dom node containing all the loop children\n   * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move\n   * @param   { Boolean } isVirtual - is it a virtual tag?\n   */\n\n\n  function move(root, nextTag, isVirtual) {\n    if (isVirtual) {\n      moveVirtual.apply(this, [root, nextTag]);\n    } else {\n      safeInsert(root, this.root, nextTag.root);\n    }\n  }\n  /**\n   * Insert and mount a child tag\n   * @this Tag\n   * @param   { HTMLElement } root - dom node containing all the loop children\n   * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert\n   * @param   { Boolean } isVirtual - is it a virtual tag?\n   */\n\n\n  function insert(root, nextTag, isVirtual) {\n    if (isVirtual) {\n      makeVirtual.apply(this, [root, nextTag]);\n    } else {\n      safeInsert(root, this.root, nextTag.root);\n    }\n  }\n  /**\n   * Append a new tag into the DOM\n   * @this Tag\n   * @param   { HTMLElement } root - dom node containing all the loop children\n   * @param   { Boolean } isVirtual - is it a virtual tag?\n   */\n\n\n  function append(root, isVirtual) {\n    if (isVirtual) {\n      makeVirtual.call(this, root);\n    } else {\n      root.appendChild(this.root);\n    }\n  }\n  /**\n   * Return the value we want to use to lookup the postion of our items in the collection\n   * @param   { String }  keyAttr         - lookup string or expression\n   * @param   { * }       originalItem    - original item from the collection\n   * @param   { Object }  keyedItem       - object created by riot via { item, i in collection }\n   * @param   { Boolean } hasKeyAttrExpr  - flag to check whether the key is an expression\n   * @returns { * } value that we will use to figure out the item position via collection.indexOf\n   */\n\n\n  function getItemId(keyAttr, originalItem, keyedItem, hasKeyAttrExpr) {\n    if (keyAttr) {\n      return hasKeyAttrExpr ? tmpl(keyAttr, keyedItem) : originalItem[keyAttr];\n    }\n\n    return originalItem;\n  }\n  /**\n   * Manage tags having the 'each'\n   * @param   { HTMLElement } dom - DOM node we need to loop\n   * @param   { Tag } parent - parent tag instance where the dom node is contained\n   * @param   { String } expr - string contained in the 'each' attribute\n   * @returns { Object } expression object for this each loop\n   */\n\n\n  function _each(dom, parent, expr) {\n    var mustReorder = typeof getAttribute(dom, LOOP_NO_REORDER_DIRECTIVE) !== T_STRING || removeAttribute(dom, LOOP_NO_REORDER_DIRECTIVE);\n    var keyAttr = getAttribute(dom, KEY_DIRECTIVE);\n    var hasKeyAttrExpr = keyAttr ? tmpl.hasExpr(keyAttr) : false;\n    var tagName = getName(dom);\n    var impl = __TAG_IMPL[tagName];\n    var parentNode = dom.parentNode;\n    var placeholder = createDOMPlaceholder();\n    var child = get(dom);\n    var ifExpr = getAttribute(dom, CONDITIONAL_DIRECTIVE);\n    var tags = [];\n    var isLoop = true;\n    var innerHTML = dom.innerHTML;\n    var isAnonymous = !__TAG_IMPL[tagName];\n    var isVirtual = dom.tagName === 'VIRTUAL';\n    var oldItems = []; // remove the each property from the original tag\n\n    removeAttribute(dom, LOOP_DIRECTIVE);\n    removeAttribute(dom, KEY_DIRECTIVE); // parse the each expression\n\n    expr = tmpl.loopKeys(expr);\n    expr.isLoop = true;\n\n    if (ifExpr) {\n      removeAttribute(dom, CONDITIONAL_DIRECTIVE);\n    } // insert a marked where the loop tags will be injected\n\n\n    parentNode.insertBefore(placeholder, dom);\n    parentNode.removeChild(dom);\n\n    expr.update = function updateEach() {\n      // get the new items collection\n      expr.value = tmpl(expr.val, parent);\n      var items = expr.value;\n      var frag = createFragment();\n      var isObject = !isArray(items) && !isString(items);\n      var root = placeholder.parentNode;\n      var tmpItems = [];\n      var hasKeys = isObject && !!items; // if this DOM was removed the update here is useless\n      // this condition fixes also a weird async issue on IE in our unit test\n\n      if (!root) {\n        return;\n      } // object loop. any changes cause full redraw\n\n\n      if (isObject) {\n        items = items ? Object.keys(items).map(function (key) {\n          return mkitem(expr, items[key], key);\n        }) : [];\n      } // store the amount of filtered items\n\n\n      var filteredItemsCount = 0; // loop all the new items\n\n      each(items, function (_item, index) {\n        var i = index - filteredItemsCount;\n        var item = !hasKeys && expr.key ? mkitem(expr, _item, index) : _item; // skip this item because it must be filtered\n\n        if (ifExpr && !tmpl(ifExpr, extend(create(parent), item))) {\n          filteredItemsCount++;\n          return;\n        }\n\n        var itemId = getItemId(keyAttr, _item, item, hasKeyAttrExpr); // reorder only if the items are not objects\n        // or a key attribute has been provided\n\n        var doReorder = !isObject && mustReorder && typeof _item === T_OBJECT || keyAttr;\n        var oldPos = oldItems.indexOf(itemId);\n        var isNew = oldPos === -1;\n        var pos = !isNew && doReorder ? oldPos : i; // does a tag exist in this position?\n\n        var tag = tags[pos];\n        var mustAppend = i >= oldItems.length;\n        var mustCreate = doReorder && isNew || !doReorder && !tag || !tags[i]; // new tag\n\n        if (mustCreate) {\n          tag = createTag(impl, {\n            parent: parent,\n            isLoop: isLoop,\n            isAnonymous: isAnonymous,\n            tagName: tagName,\n            root: dom.cloneNode(isAnonymous),\n            item: item,\n            index: i\n          }, innerHTML); // mount the tag\n\n          tag.mount();\n\n          if (mustAppend) {\n            append.apply(tag, [frag || root, isVirtual]);\n          } else {\n            insert.apply(tag, [root, tags[i], isVirtual]);\n          }\n\n          if (!mustAppend) {\n            oldItems.splice(i, 0, item);\n          }\n\n          tags.splice(i, 0, tag);\n\n          if (child) {\n            arrayishAdd(parent.tags, tagName, tag, true);\n          }\n        } else if (pos !== i && doReorder) {\n          // move\n          if (keyAttr || contains(items, oldItems[pos])) {\n            move.apply(tag, [root, tags[i], isVirtual]); // move the old tag instance\n\n            tags.splice(i, 0, tags.splice(pos, 1)[0]); // move the old item\n\n            oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);\n          } // update the position attribute if it exists\n\n\n          if (expr.pos) {\n            tag[expr.pos] = i;\n          } // if the loop tags are not custom\n          // we need to move all their custom tags into the right position\n\n\n          if (!child && tag.tags) {\n            moveNestedTags.call(tag, i);\n          }\n        } // cache the original item to use it in the events bound to this node\n        // and its children\n\n\n        extend(tag.__, {\n          item: item,\n          index: i,\n          parent: parent\n        });\n        tmpItems[i] = itemId;\n\n        if (!mustCreate) {\n          tag.update(item);\n        }\n      }); // remove the redundant tags\n\n      unmountRedundant(items, tags, filteredItemsCount); // clone the items array\n\n      oldItems = tmpItems.slice();\n      root.insertBefore(frag, placeholder);\n    };\n\n    expr.unmount = function () {\n      each(tags, function (t) {\n        t.unmount();\n      });\n    };\n\n    return expr;\n  }\n\n  var RefExpr = {\n    init: function init(dom, parent, attrName, attrValue) {\n      this.dom = dom;\n      this.attr = attrName;\n      this.rawValue = attrValue;\n      this.parent = parent;\n      this.hasExp = tmpl.hasExpr(attrValue);\n      return this;\n    },\n    update: function update() {\n      var old = this.value;\n      var customParent = this.parent && getImmediateCustomParent(this.parent); // if the referenced element is a custom tag, then we set the tag itself, rather than DOM\n\n      var tagOrDom = this.dom.__ref || this.tag || this.dom;\n      this.value = this.hasExp ? tmpl(this.rawValue, this.parent) : this.rawValue; // the name changed, so we need to remove it from the old key (if present)\n\n      if (!isBlank(old) && customParent) {\n        arrayishRemove(customParent.refs, old, tagOrDom);\n      }\n\n      if (!isBlank(this.value) && isString(this.value)) {\n        // add it to the refs of parent tag (this behavior was changed >=3.0)\n        if (customParent) {\n          arrayishAdd(customParent.refs, this.value, tagOrDom, // use an array if it's a looped node and the ref is not an expression\n          null, this.parent.__.index);\n        }\n\n        if (this.value !== old) {\n          setAttribute(this.dom, this.attr, this.value);\n        }\n      } else {\n        removeAttribute(this.dom, this.attr);\n      } // cache the ref bound to this dom node\n      // to reuse it in future (see also #2329)\n\n\n      if (!this.dom.__ref) {\n        this.dom.__ref = tagOrDom;\n      }\n    },\n    unmount: function unmount() {\n      var tagOrDom = this.tag || this.dom;\n      var customParent = this.parent && getImmediateCustomParent(this.parent);\n\n      if (!isBlank(this.value) && customParent) {\n        arrayishRemove(customParent.refs, this.value, tagOrDom);\n      }\n    }\n  };\n  /**\n   * Create a new ref directive\n   * @param   { HTMLElement } dom - dom node having the ref attribute\n   * @param   { Tag } context - tag instance where the DOM node is located\n   * @param   { String } attrName - either 'ref' or 'data-ref'\n   * @param   { String } attrValue - value of the ref attribute\n   * @returns { RefExpr } a new RefExpr object\n   */\n\n  function createRefDirective(dom, tag, attrName, attrValue) {\n    return create(RefExpr).init(dom, tag, attrName, attrValue);\n  }\n  /**\n   * Trigger the unmount method on all the expressions\n   * @param   { Array } expressions - DOM expressions\n   */\n\n\n  function unmountAll(expressions) {\n    each(expressions, function (expr) {\n      if (expr.unmount) {\n        expr.unmount(true);\n      } else if (expr.tagName) {\n        expr.tag.unmount(true);\n      } else if (expr.unmount) {\n        expr.unmount();\n      }\n    });\n  }\n\n  var IfExpr = {\n    init: function init(dom, tag, expr) {\n      removeAttribute(dom, CONDITIONAL_DIRECTIVE);\n      extend(this, {\n        tag: tag,\n        expr: expr,\n        stub: createDOMPlaceholder(),\n        pristine: dom\n      });\n      var p = dom.parentNode;\n      p.insertBefore(this.stub, dom);\n      p.removeChild(dom);\n      return this;\n    },\n    update: function update$$1() {\n      this.value = tmpl(this.expr, this.tag);\n\n      if (!this.stub.parentNode) {\n        return;\n      }\n\n      if (this.value && !this.current) {\n        // insert\n        this.current = this.pristine.cloneNode(true);\n        this.stub.parentNode.insertBefore(this.current, this.stub);\n        this.expressions = parseExpressions.apply(this.tag, [this.current, true]);\n      } else if (!this.value && this.current) {\n        // remove\n        this.unmount();\n        this.current = null;\n        this.expressions = [];\n      }\n\n      if (this.value) {\n        update.call(this.tag, this.expressions);\n      }\n    },\n    unmount: function unmount() {\n      if (this.current) {\n        if (this.current._tag) {\n          this.current._tag.unmount();\n        } else if (this.current.parentNode) {\n          this.current.parentNode.removeChild(this.current);\n        }\n      }\n\n      unmountAll(this.expressions || []);\n    }\n  };\n  /**\n   * Create a new if directive\n   * @param   { HTMLElement } dom - if root dom node\n   * @param   { Tag } context - tag instance where the DOM node is located\n   * @param   { String } attr - if expression\n   * @returns { IFExpr } a new IfExpr object\n   */\n\n  function createIfDirective(dom, tag, attr) {\n    return create(IfExpr).init(dom, tag, attr);\n  }\n  /**\n   * Walk the tag DOM to detect the expressions to evaluate\n   * @this Tag\n   * @param   { HTMLElement } root - root tag where we will start digging the expressions\n   * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well\n   * @returns { Array } all the expressions found\n   */\n\n\n  function parseExpressions(root, mustIncludeRoot) {\n    var this$1 = this;\n    var expressions = [];\n    walkNodes(root, function (dom) {\n      var type = dom.nodeType;\n      var attr;\n      var tagImpl;\n\n      if (!mustIncludeRoot && dom === root) {\n        return;\n      } // text node\n\n\n      if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue)) {\n        expressions.push({\n          dom: dom,\n          expr: dom.nodeValue\n        });\n      }\n\n      if (type !== 1) {\n        return;\n      }\n\n      var isVirtual = dom.tagName === 'VIRTUAL'; // loop. each does it's own thing (for now)\n\n      if (attr = getAttribute(dom, LOOP_DIRECTIVE)) {\n        if (isVirtual) {\n          setAttribute(dom, 'loopVirtual', true);\n        } // ignore here, handled in _each\n\n\n        expressions.push(_each(dom, this$1, attr));\n        return false;\n      } // if-attrs become the new parent. Any following expressions (either on the current\n      // element, or below it) become children of this expression.\n\n\n      if (attr = getAttribute(dom, CONDITIONAL_DIRECTIVE)) {\n        expressions.push(createIfDirective(dom, this$1, attr));\n        return false;\n      }\n\n      if (attr = getAttribute(dom, IS_DIRECTIVE)) {\n        if (tmpl.hasExpr(attr)) {\n          expressions.push({\n            isRtag: true,\n            expr: attr,\n            dom: dom,\n            attrs: [].slice.call(dom.attributes)\n          });\n          return false;\n        }\n      } // if this is a tag, stop traversing here.\n      // we ignore the root, since parseExpressions is called while we're mounting that root\n\n\n      tagImpl = get(dom);\n\n      if (isVirtual) {\n        if (getAttribute(dom, 'virtualized')) {\n          dom.parentElement.removeChild(dom);\n        } // tag created, remove from dom\n\n\n        if (!tagImpl && !getAttribute(dom, 'virtualized') && !getAttribute(dom, 'loopVirtual')) // ok to create virtual tag\n          {\n            tagImpl = {\n              tmpl: dom.outerHTML\n            };\n          }\n      }\n\n      if (tagImpl && (dom !== root || mustIncludeRoot)) {\n        var hasIsDirective = getAttribute(dom, IS_DIRECTIVE);\n\n        if (isVirtual && !hasIsDirective) {\n          // handled in update\n          // can not remove attribute like directives\n          // so flag for removal after creation to prevent maximum stack error\n          setAttribute(dom, 'virtualized', true);\n          var tag = createTag({\n            tmpl: dom.outerHTML\n          }, {\n            root: dom,\n            parent: this$1\n          }, dom.innerHTML);\n          expressions.push(tag); // no return, anonymous tag, keep parsing\n        } else {\n          if (hasIsDirective && isVirtual) {\n            warn(\"Virtual tags shouldn't be used together with the \\\"\" + IS_DIRECTIVE + \"\\\" attribute - https://github.com/riot/riot/issues/2511\");\n          }\n\n          expressions.push(initChild(tagImpl, {\n            root: dom,\n            parent: this$1\n          }, dom.innerHTML, this$1));\n          return false;\n        }\n      } // attribute expressions\n\n\n      parseAttributes.apply(this$1, [dom, dom.attributes, function (attr, expr) {\n        if (!expr) {\n          return;\n        }\n\n        expressions.push(expr);\n      }]);\n    });\n    return expressions;\n  }\n  /**\n   * Calls `fn` for every attribute on an element. If that attr has an expression,\n   * it is also passed to fn.\n   * @this Tag\n   * @param   { HTMLElement } dom - dom node to parse\n   * @param   { Array } attrs - array of attributes\n   * @param   { Function } fn - callback to exec on any iteration\n   */\n\n\n  function parseAttributes(dom, attrs, fn) {\n    var this$1 = this;\n    each(attrs, function (attr) {\n      if (!attr) {\n        return false;\n      }\n\n      var name = attr.name;\n      var bool = isBoolAttr(name);\n      var expr;\n\n      if (contains(REF_DIRECTIVES, name) && dom.tagName.toLowerCase() !== YIELD_TAG) {\n        expr = createRefDirective(dom, this$1, name, attr.value);\n      } else if (tmpl.hasExpr(attr.value)) {\n        expr = {\n          dom: dom,\n          expr: attr.value,\n          attr: name,\n          bool: bool\n        };\n      }\n\n      fn(attr, expr);\n    });\n  }\n  /**\n   * Manage the mount state of a tag triggering also the observable events\n   * @this Tag\n   * @param { Boolean } value - ..of the isMounted flag\n   */\n\n\n  function setMountState(value) {\n    var ref = this.__;\n    var isAnonymous = ref.isAnonymous;\n    var skipAnonymous = ref.skipAnonymous;\n    define(this, 'isMounted', value);\n\n    if (!isAnonymous || !skipAnonymous) {\n      if (value) {\n        this.trigger('mount');\n      } else {\n        this.trigger('unmount');\n        this.off('*');\n        this.__.wasCreated = false;\n      }\n    }\n  }\n  /**\n   * Mount the current tag instance\n   * @returns { Tag } the current tag instance\n   */\n\n\n  function componentMount(tag$$1, dom, expressions, opts) {\n    var __ = tag$$1.__;\n    var root = __.root;\n    root._tag = tag$$1; // keep a reference to the tag just created\n    // Read all the attrs on this instance. This give us the info we need for updateOpts\n\n    parseAttributes.apply(__.parent, [root, root.attributes, function (attr, expr) {\n      if (!__.isAnonymous && RefExpr.isPrototypeOf(expr)) {\n        expr.tag = tag$$1;\n      }\n\n      attr.expr = expr;\n\n      __.instAttrs.push(attr);\n    }]); // update the root adding custom attributes coming from the compiler\n\n    walkAttributes(__.impl.attrs, function (k, v) {\n      __.implAttrs.push({\n        name: k,\n        value: v\n      });\n    });\n    parseAttributes.apply(tag$$1, [root, __.implAttrs, function (attr, expr) {\n      if (expr) {\n        expressions.push(expr);\n      } else {\n        setAttribute(root, attr.name, attr.value);\n      }\n    }]); // initialiation\n\n    updateOpts.apply(tag$$1, [__.isLoop, __.parent, __.isAnonymous, opts, __.instAttrs]); // add global mixins\n\n    var globalMixin = mixin(GLOBAL_MIXIN);\n\n    if (globalMixin && !__.skipAnonymous) {\n      for (var i in globalMixin) {\n        if (globalMixin.hasOwnProperty(i)) {\n          tag$$1.mixin(globalMixin[i]);\n        }\n      }\n    }\n\n    if (__.impl.fn) {\n      __.impl.fn.call(tag$$1, opts);\n    }\n\n    if (!__.skipAnonymous) {\n      tag$$1.trigger('before-mount');\n    } // parse layout after init. fn may calculate args for nested custom tags\n\n\n    each(parseExpressions.apply(tag$$1, [dom, __.isAnonymous]), function (e) {\n      return expressions.push(e);\n    });\n    tag$$1.update(__.item);\n\n    if (!__.isAnonymous && !__.isInline) {\n      while (dom.firstChild) {\n        root.appendChild(dom.firstChild);\n      }\n    }\n\n    define(tag$$1, 'root', root); // if we need to wait that the parent \"mount\" or \"updated\" event gets triggered\n\n    if (!__.skipAnonymous && tag$$1.parent) {\n      var p = getImmediateCustomParent(tag$$1.parent);\n      p.one(!p.isMounted ? 'mount' : 'updated', function () {\n        setMountState.call(tag$$1, true);\n      });\n    } else {\n      // otherwise it's not a child tag we can trigger its mount event\n      setMountState.call(tag$$1, true);\n    }\n\n    tag$$1.__.wasCreated = true;\n    return tag$$1;\n  }\n  /**\n   * Unmount the tag instance\n   * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed\n   * @returns { Tag } the current tag instance\n   */\n\n\n  function tagUnmount(tag, mustKeepRoot, expressions) {\n    var __ = tag.__;\n    var root = __.root;\n\n    var tagIndex = __TAGS_CACHE.indexOf(tag);\n\n    var p = root.parentNode;\n\n    if (!__.skipAnonymous) {\n      tag.trigger('before-unmount');\n    } // clear all attributes coming from the mounted tag\n\n\n    walkAttributes(__.impl.attrs, function (name) {\n      if (startsWith(name, ATTRS_PREFIX)) {\n        name = name.slice(ATTRS_PREFIX.length);\n      }\n\n      removeAttribute(root, name);\n    }); // remove all the event listeners\n\n    tag.__.listeners.forEach(function (dom) {\n      Object.keys(dom[RIOT_EVENTS_KEY]).forEach(function (eventName) {\n        dom.removeEventListener(eventName, dom[RIOT_EVENTS_KEY][eventName]);\n      });\n    }); // remove tag instance from the global tags cache collection\n\n\n    if (tagIndex !== -1) {\n      __TAGS_CACHE.splice(tagIndex, 1);\n    } // clean up the parent tags object\n\n\n    if (__.parent && !__.isAnonymous) {\n      var ptag = getImmediateCustomParent(__.parent);\n\n      if (__.isVirtual) {\n        Object.keys(tag.tags).forEach(function (tagName) {\n          return arrayishRemove(ptag.tags, tagName, tag.tags[tagName]);\n        });\n      } else {\n        arrayishRemove(ptag.tags, __.tagName, tag);\n      }\n    } // unmount all the virtual directives\n\n\n    if (tag.__.virts) {\n      each(tag.__.virts, function (v) {\n        if (v.parentNode) {\n          v.parentNode.removeChild(v);\n        }\n      });\n    } // allow expressions to unmount themselves\n\n\n    unmountAll(expressions);\n    each(__.instAttrs, function (a) {\n      return a.expr && a.expr.unmount && a.expr.unmount();\n    }); // clear the tag html if it's necessary\n\n    if (mustKeepRoot) {\n      setInnerHTML(root, '');\n    } // otherwise detach the root tag from the DOM\n    else if (p) {\n        p.removeChild(root);\n      } // custom internal unmount function to avoid relying on the observable\n\n\n    if (__.onUnmount) {\n      __.onUnmount();\n    } // weird fix for a weird edge case #2409 and #2436\n    // some users might use your software not as you've expected\n    // so I need to add these dirty hacks to mitigate unexpected issues\n\n\n    if (!tag.isMounted) {\n      setMountState.call(tag, true);\n    }\n\n    setMountState.call(tag, false);\n    delete root._tag;\n    return tag;\n  }\n  /**\n   * Tag creation factory function\n   * @constructor\n   * @param { Object } impl - it contains the tag template, and logic\n   * @param { Object } conf - tag options\n   * @param { String } innerHTML - html that eventually we need to inject in the tag\n   */\n\n\n  function createTag(impl, conf, innerHTML) {\n    if (impl === void 0) impl = {};\n    if (conf === void 0) conf = {};\n    var tag = conf.context || {};\n    var opts = conf.opts || {};\n    var parent = conf.parent;\n    var isLoop = conf.isLoop;\n    var isAnonymous = !!conf.isAnonymous;\n    var skipAnonymous = settings.skipAnonymousTags && isAnonymous;\n    var item = conf.item; // available only for the looped nodes\n\n    var index = conf.index; // All attributes on the Tag when it's first parsed\n\n    var instAttrs = []; // expressions on this type of Tag\n\n    var implAttrs = [];\n    var tmpl = impl.tmpl;\n    var expressions = [];\n    var root = conf.root;\n    var tagName = conf.tagName || getName(root);\n    var isVirtual = tagName === 'virtual';\n    var isInline = !isVirtual && !tmpl;\n    var dom;\n\n    if (isInline || isLoop && isAnonymous) {\n      dom = root;\n    } else {\n      if (!isVirtual) {\n        root.innerHTML = '';\n      }\n\n      dom = mkdom(tmpl, innerHTML, isSvg(root));\n    } // make this tag observable\n\n\n    if (!skipAnonymous) {\n      observable(tag);\n    } // only call unmount if we have a valid __TAG_IMPL (has name property)\n\n\n    if (impl.name && root._tag) {\n      root._tag.unmount(true);\n    }\n\n    define(tag, '__', {\n      impl: impl,\n      root: root,\n      skipAnonymous: skipAnonymous,\n      implAttrs: implAttrs,\n      isAnonymous: isAnonymous,\n      instAttrs: instAttrs,\n      innerHTML: innerHTML,\n      tagName: tagName,\n      index: index,\n      isLoop: isLoop,\n      isInline: isInline,\n      item: item,\n      parent: parent,\n      // tags having event listeners\n      // it would be better to use weak maps here but we can not introduce breaking changes now\n      listeners: [],\n      // these vars will be needed only for the virtual tags\n      virts: [],\n      wasCreated: false,\n      tail: null,\n      head: null\n    }); // tag protected properties\n\n    return [['isMounted', false], // create a unique id to this tag\n    // it could be handy to use it also to improve the virtual dom rendering speed\n    ['_riot_id', uid()], ['root', root], ['opts', opts, {\n      writable: true,\n      enumerable: true\n    }], ['parent', parent || null], // protect the \"tags\" and \"refs\" property from being overridden\n    ['tags', {}], ['refs', {}], ['update', function (data) {\n      return componentUpdate(tag, data, expressions);\n    }], ['mixin', function () {\n      var mixins = [],\n          len = arguments.length;\n\n      while (len--) mixins[len] = arguments[len];\n\n      return componentMixin.apply(void 0, [tag].concat(mixins));\n    }], ['mount', function () {\n      return componentMount(tag, dom, expressions, opts);\n    }], ['unmount', function (mustKeepRoot) {\n      return tagUnmount(tag, mustKeepRoot, expressions);\n    }]].reduce(function (acc, ref) {\n      var key = ref[0];\n      var value = ref[1];\n      var opts = ref[2];\n      define(tag, key, value, opts);\n      return acc;\n    }, extend(tag, item));\n  }\n  /**\n   * Mount a tag creating new Tag instance\n   * @param   { Object } root - dom node where the tag will be mounted\n   * @param   { String } tagName - name of the riot tag we want to mount\n   * @param   { Object } opts - options to pass to the Tag instance\n   * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )\n   * @returns { Tag } a new Tag instance\n   */\n\n\n  function mount$1(root, tagName, opts, ctx) {\n    var impl = __TAG_IMPL[tagName];\n    var implClass = __TAG_IMPL[tagName].class;\n    var context = ctx || (implClass ? create(implClass.prototype) : {}); // cache the inner HTML to fix #855\n\n    var innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;\n    var conf = extend({\n      root: root,\n      opts: opts,\n      context: context\n    }, {\n      parent: opts ? opts.parent : null\n    });\n    var tag;\n\n    if (impl && root) {\n      tag = createTag(impl, conf, innerHTML);\n    }\n\n    if (tag && tag.mount) {\n      tag.mount(true); // add this tag to the virtualDom variable\n\n      if (!contains(__TAGS_CACHE, tag)) {\n        __TAGS_CACHE.push(tag);\n      }\n    }\n\n    return tag;\n  }\n\n  var tags =\n  /*#__PURE__*/\n  Object.freeze({\n    arrayishAdd: arrayishAdd,\n    getTagName: getName,\n    inheritParentProps: inheritParentProps,\n    mountTo: mount$1,\n    selectTags: query,\n    arrayishRemove: arrayishRemove,\n    getTag: get,\n    initChildTag: initChild,\n    moveChildTag: moveChild,\n    makeReplaceVirtual: makeReplaceVirtual,\n    getImmediateCustomParentTag: getImmediateCustomParent,\n    makeVirtual: makeVirtual,\n    moveVirtual: moveVirtual,\n    unmountAll: unmountAll,\n    createIfDirective: createIfDirective,\n    createRefDirective: createRefDirective\n  });\n  /**\n   * Riot public api\n   */\n\n  var settings$1 = settings;\n  var util = {\n    tmpl: tmpl,\n    brackets: brackets,\n    styleManager: styleManager,\n    vdom: __TAGS_CACHE,\n    styleNode: styleManager.styleNode,\n    // export the riot internal utils as well\n    dom: dom,\n    check: check,\n    misc: misc,\n    tags: tags\n  }; // export the core props/methods\n\n  var Tag$1 = Tag;\n  var tag$1 = tag;\n  var tag2$1 = tag2;\n  var mount$2 = mount;\n  var mixin$1 = mixin;\n  var update$2 = update$1;\n  var unregister$1 = unregister;\n  var version$1 = version;\n  var observable$1 = observable;\n  var riot$1 = extend({}, core, {\n    observable: observable,\n    settings: settings$1,\n    util: util\n  });\n  exports.settings = settings$1;\n  exports.util = util;\n  exports.Tag = Tag$1;\n  exports.tag = tag$1;\n  exports.tag2 = tag2$1;\n  exports.mount = mount$2;\n  exports.mixin = mixin$1;\n  exports.update = update$2;\n  exports.unregister = unregister$1;\n  exports.version = version$1;\n  exports.observable = observable$1;\n  exports.default = riot$1;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null},"hash":"f2e8ab8d279cc01dd7701e7d6a263d91","cacheData":{"env":{}}}